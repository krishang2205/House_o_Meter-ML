# -*- coding: utf-8 -*-
"""RealEstate_Price_Prediction .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vK-mHyy_ot9MNRki28p4Gil1CsfoBw9J

**Importing And Exploring Dataset**
"""

import warnings
warnings.filterwarnings('ignore')
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

import pandas as pd
data = pd.read_csv('Bengaluru_House_Data.csv')

data.head(15)

data.drop_duplicates(inplace=True)

data['availability'].unique()

data.info()

"""**Data Cleaning and Initial Processing**

---


"""

data.rename(columns={'size': 'size(BHK)'}, inplace=True)
# Convert to numeric, invalid parsing will be set as NaN
data['size(BHK)'] = pd.to_numeric(data['size(BHK)'].str.extract('(\d+)')[0], errors='coerce')

data['total_sqft'].unique()

def convert_range_to_num(x):
    temp = x.split('-')
    if len(temp) == 2:
        return (float(temp[0]) + float(temp[1])) / 2
    try:
        return float(x)
    except:
        return None

data['total_sqft'] = data['total_sqft'].apply(convert_range_to_num)

data.isnull().sum()

data.drop('society', axis=1, inplace=True)

"""Handling Missing Values

"""

data['location'].fillna(data['location'].mode()[0], inplace=True)
data['balcony'].fillna(data['balcony'].median(), inplace=True)
data['bath'].fillna(data['bath'].median(), inplace=True)
data['size(BHK)'].fillna(data['size(BHK)'].median(), inplace=True)
data['price'].fillna(data['price'].median(), inplace=True)
data['total_sqft'].fillna(data['total_sqft'].median(), inplace=True)
data['availability'].fillna(data['availability'].mode()[0], inplace=True)

data.isnull().sum()

"""**Feature_Engineering**

### Dimensionality Reduction
Any location having less than 10 data points should be tagged as "other" location. This way number of categories can be reduced by huge amount. Later on when we do one hot encoding, it will help us with having fewer dummy columns
"""

data.location.unique()
len(data.location.unique())

data.location = data.location.apply(lambda x: x.strip()) # removing white space

location_stats= data.groupby('location')['location'].agg('count')
location_stats

location_stats= data.groupby('location')['location'].agg('count').sort_values(ascending=False)
location_stats

len(location_stats[location_stats<=5])

location_stats_less_then_10 = location_stats[location_stats<=10]
location_stats_less_then_10

len(data.location.unique())
data.location = data.location.apply(lambda x: 'Other' if x in location_stats_less_then_10 else x)
len(data.location.unique())
# Get unique values from the 'location' column
unique_locations = data['location'].unique()



print(len(unique_locations))

data.head(50)

data.info()

data['price_per_sqft'] = data['price'] * 100000 / data['total_sqft']

data.loc[data['availability'] !='Ready To Move','availability'] = 'Under Construction'

print(data.shape)

# Save the cleaned dataset to a new CSV file
data.to_csv('Bengaluru_House_Data_temp.csv', index=False)
data1=pd.read_csv('Bengaluru_House_Data_temp.csv')

"""**Handling Outliers**

"""

# Select only the numerical columns
numerical_features = data1.select_dtypes(include=['int64', 'float64']).columns

# Print the numerical features
print("Numerical Features:")
print(numerical_features)
for feature in numerical_features:
    plt.figure(figsize=(10, 5))
    sns.histplot(data1[feature], bins=30, kde=True)
    plt.title(f'{feature} Distribution')
    plt.show()

for feature in numerical_features:
  plt.figure(figsize=(10, 5))
  sns.boxplot(x=data1[feature])
  plt.title(f'{feature} Boxplot')
  plt.show()

data1.describe()

(data1['total_sqft'] / data1['size(BHK)']).describe()

data1 = data1[((data1['total_sqft'] / data1['size(BHK)']) >= 300)]
data1.describe()

data1.price_per_sqft.describe()

def remove_outliers_sqft(df):
    data1_output = pd.DataFrame()
    for key,subdata1 in data1.groupby('location'):
        m = np.mean(subdata1.price_per_sqft)
        st = np.std(subdata1.price_per_sqft)
        gen_data1 = subdata1[(subdata1.price_per_sqft > (m - st)) & (subdata1.price_per_sqft <= (m + st))]
        data1_output = pd.concat([data1_output, gen_data1], ignore_index = True)
    return data1_output
data1 = remove_outliers_sqft(data1)
data1.describe()

def bhk_outlier_remover(df):
    exclude_indices = np.array([])
    for location, location_df in df.groupby('location'):
        bhk_stats = {}
        for bhk, bhk_df in location_df.groupby('size(BHK)'):
            bhk_stats[bhk] = {
                'mean':np.mean(bhk_df.price_per_sqft),
                'std':np.std(bhk_df.price_per_sqft),
                'count':bhk_df.shape[0]
            }
        for bhk, bhk_df in location_df.groupby('size(BHK)'):
            stats = bhk_stats.get(bhk - 1)
            if stats and stats['count'] > 5:
                exclude_indices = np.append(exclude_indices, bhk_df[bhk_df.price_per_sqft < (stats['mean'])].index.values)
    return df.drop(exclude_indices, axis = 'index')

data1 = bhk_outlier_remover(data1)

data1.shape

import pandas as pd
print("statsbefore:",data1.describe())
# Define a function to remove outliers using IQR for each numerical feature
def remove_outliers(data, column):
    # Calculate Q1 (25th percentile) and Q3 (75th percentile)
    Q1 = data[column].quantile(0.25)
    Q3 = data[column].quantile(0.75)
    IQR = Q3 - Q1  # Interquartile range

    # Define the lower and upper bounds for outliers
    lower_bound = Q1 - 1.5* IQR
    upper_bound = Q3 + 1.5 * IQR

    # Filter out rows with outliers in the specified column
    data = data[(data[column] >= lower_bound) & (data[column] <= upper_bound)]
    return data

# Remove outliers from each specified column and update data2
for col in ['size(BHK)',  'bath','total_sqft', 'price','price_per_sqft']:
  data1 = remove_outliers(data1,col )  # Update data after each outlier removal

# Display the cleaned dataset
print("statafter:",data1.describe())
print("Shape after removing outliers:", data1.shape)

for feature in numerical_features:
    plt.figure(figsize=(10, 5))
    sns.histplot(data1[feature], bins=30, kde=True)
    plt.title(f'{feature} Distribution')
    plt.show()

for feature in numerical_features:
  plt.figure(figsize=(10, 5))
  sns.boxplot(x=data1[feature])
  plt.title(f'{feature} Boxplot')
  plt.show()

print(data1.shape)

data1.to_csv('Cleaned_Bengaluru_House_Data.csv', index=False)

data2 = pd.read_csv('Cleaned_Bengaluru_House_Data.csv')
data2.describe()

data1.head(25)